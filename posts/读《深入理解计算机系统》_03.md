# 读《深入理解计算机系统》（三）


- [读《深入理解计算机系统》（一）](https://github.com/ShannonChenCHN/what-is-computer-science/blob/master/posts/%E8%AF%BB%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B_01.md)
- [读《深入理解计算机系统》（二）](https://github.com/ShannonChenCHN/what-is-computer-science/blob/master/posts/%E8%AF%BB%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B_02.md)
- [读《深入理解计算机系统》（三）](https://github.com/ShannonChenCHN/what-is-computer-science/blob/master/posts/%E8%AF%BB%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B_03.md)
- [读《深入理解计算机系统》（四）](https://github.com/ShannonChenCHN/what-is-computer-science/blob/master/posts/%E8%AF%BB%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B_04.md)

## 目录

- 第二部分 在系统上运行程序
  - 第7章　链接
    - 7.1 编译器驱动程序
    - 7.2 静态链接
    - 7.3 目标文件
    - 7.4 可重定位目标文件
    - 7.5 符号和符号表
    - 7.6 符号解析
    - 7.7 重定位
    - 7.8 可执行目标文件
    - 7.9 加载可执行目标文件
    - 7.10 动态链接共享库
    - 7.11 从应用程序中加载和链接共享库
    - 7.12 位置无关代码
    - 7.13 库打桩机制
    - 7.14 处理目标文件的工具
  - 第8章　异常控制流
    - 8.1 异常
    - 8.2 进程
    - 8.3 系统调用错误处理
    - 8.4 进程控制
    - 8.5 信号
    - 8.6 非本地跳转
    - 8.7 操作进程的工具
  - 第9章　虚拟内存
    - 9.1 物理寻址和虚拟寻址
    - 9.2 地址空间
    - 9.3 虚拟内存作为缓存的工具
    - 9.4 虚拟内存作为内存管理的工具
    - 9.5 虚拟内存作为内存保护的工具
    - 9.6 地址翻译
    - 9.7 案例研究：Intel Core i7/Linux 内存系统
    - 9.8 内存映射
    - 9.9 动态内存分配
    - 9.10 垃圾收集
    - 9.11 C 程序中常见的与内存有关的错误


## 第二部分 在系统上运行程序

## 第 7 章　链接

### 问题

- 什么是链接？
  - 链接是将各种代码和数据片段收集并组合成一个单一文件的过程，这个文件可被加载（复制）到内存并执行。
- 链接执行的时机
  - 编译时
  - 加载时
  - 运行时
- 链接器
- 为什么需要链接？
  - 分离编译


### 7.1 编译器驱动程序


### 7.2 静态链接
### 7.3 目标文件
### 7.4 可重定位目标文件
### 7.5 符号和符号表
### 7.6 符号解析

- 链接器如何解析多重定义的全局符号
- 与静态库链接
- 链接器如何使用静态库来解析引用


### 7.7 重定位

- 重定位条目
- 重定位符号引用


### 7.8 可执行目标文件
### 7.9 加载可执行目标文件
### 7.10 动态链接共享库
### 7.11 从应用程序中加载和链接共享库
### 7.12 位置无关代码
### 7.13 库打桩机制

- 编译时打桩
- 链接时打桩
- 运行时打桩

### 7.14 处理目标文件的工具

## 第 8 章　异常控制流

### 问题

- 什么是异常控制流？
- 异常可以分为几种类型？
- 异常控制流和进程的关系？
- 什么是进程？
- 如何操作进程？

### 8.1 异常

- 异常处理
- 异常的类别
- Linux/x86-64 系统中的异常

### 8.2 进程

- 逻辑控制流
- 并发流
- 私有地址空间
- 用户模式和内核模式
- 上下文切换


### 8.3 系统调用错误处理




### 8.4 进程控制

- 获取进程 ID
- 创建和终止进程
- 回收子进程
- 加载并运行程序
- 利用 fork 和 execve 运行程序

### 8.5 信号

- 信号术语
- 发送信号
- 接收信号
- 阻塞和解除阻塞信号
- 编写信号处理程序
- 同步流以避免讨厌的并发错误
- 显式地等待信号


### 8.6 非本地跳转
### 8.7 操作进程的工具

## 第9章　虚拟内存

### 问题
- 什么是虚拟内存？
- 为什么需要虚拟内存？
- 虚拟内存提供了什么能力？
- 为什么我们需要学习虚拟内存？
- 虚拟内存是如何工作的？
- 应用程序如何使用和管理虚拟内存？


### 9.1 物理寻址和虚拟寻址



### 9.2 地址空间


### 9.3 虚拟内存作为缓存的工具


- DRAM 缓存的组织结构
- 页表
- 页命中
- 缺页
- 分配页面
- 又是局部性救了我们

### 9.4 虚拟内存作为内存管理的工具


### 9.5 虚拟内存作为内存保护的工具


### 9.6 地址翻译

- 结合高速缓存和虚拟内存
- 利用 TLB 加速地址翻译
- 多级页表
- 综合：端到端的地址翻译


### 9.7 案例研究：Intel Core i7/Linux 内存系统

- Core i7 地址翻译
- Linux 虚拟内存系统


### 9.8 内存映射

- 再看共享对象
- 再看 fork 函数
- 再看 execve 函数
- 使用 mmap 函数的用户级内存映射

### 9.9 动态内存分配

- malloc 和 free 函数
- 为什么要使用动态内存分配
- 分配器的要求和目标
- 碎片
- 实现问题
- 隐式空闲链表
- 放置已分配的块
- 分割空闲块
- 获取额外的堆内存
- 合并空闲块
- 带边界标记的合并
- 综合：实现一个简单的分配器
- 显式空闲链表
- 分离的空闲链表

### 9.10 垃圾收集

- 垃圾收集器的基本知识
- Mark & Sweep 垃圾收集器
- C 程序的保守 Mark & Sweep

### 9.11 C 程序中常见的与内存有关的错误

- 间接引用坏指针
- 读未初始化的内存
- 允许栈缓冲区溢出
- 假设指针和它们指向的对象是相同大小的
- 造成错位错误
- 引用指针，而不是它所指向的对象
- 误解指针运算
- 引用不存在的变量
- 引用空闲堆块中的数据
- 引起内存泄漏







